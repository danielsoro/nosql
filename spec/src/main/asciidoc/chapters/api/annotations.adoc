// Copyright (c) 2022 Contributors to the Eclipse Foundation
//
// This program and the accompanying materials are made available under the
// terms of the Eclipse Public License v. 2.0 which is available at
// http://www.eclipse.org/legal/epl-2.0.
//
// This Source Code may also be made available under the following Secondary
// Licenses when the conditions for such availability set forth in the Eclipse
// Public License v. 2.0 are satisfied: GNU General Public License, version 2
// with the GNU Classpath Exception which is available at
// https://www.gnu.org/software/classpath/license.html.
//
// SPDX-License-Identifier: EPL-2.0 OR GPL-2.0 WITH Classpath-exception-2.0

== Annotations

Jakarta NoSQL introduces a comprehensive set of annotations tailored to streamline and simplify mapping Java entities to NoSQL databases. These annotations offer:

* A standardized approach for defining entity classes, marked with `@Entity`, to establish the structural blueprint of data entities within the NoSQL environment.
* Precise specification of primary keys using the `@Id` annotation, essential for uniquely identifying entities within the database.
* Flexible mapping of entity properties to database fields through the `@Column` annotation, ensuring seamless integration of Java objects with NoSQL data storage.
* Conversion of non-persistent object types to database-compatible formats facilitated by the `@Convert` annotation, enhancing compatibility and data manipulation capabilities.
* Embedding of objects within entity structures enabled by the `@Embeddable` annotation, allowing for efficient storage of complex data structures as part of owning entities.
* Abstraction of common properties and behaviors across multiple entity classes through the `@MappedSuperclass` annotation, promoting code reusability and maintainability.
* Specifying inheritance strategies using the `@Inheritance`, `@DiscriminatorValue`, and `@DiscriminatorColumn` annotations facilitates polymorphic data modeling within the NoSQL environment.

Jakarta NoSQL has support for those nine types:

1. @Entity
2. @Embeddable
3. @Id
4. @Column
5. @Convert
6. @MappedSuperclass
7. @Inheritance
8. @DiscriminatorValue
9. @DiscriminatorColumn

In the realm of Jakarta NoSQL, developers wield a powerful arsenal of annotations tailored to meet diverse data modeling needs:

* **@Entity**: The `@Entity` annotation signifies that a Java class represents a persistent entity with a lifecycle managed by the underlying data store. By annotating a class with `@Entity`, developers indicate that instances of this class are subject to CRUD (Create, Read, Update, Delete) operations within the NoSQL database. This annotation not only defines the entity's structure but also denotes its existence beyond the scope of a single Java application instance. In essence, the `@Entity` annotation encapsulates the notion of a domain object that persists beyond the lifetime of a Java process, ensuring consistency and durability in data management.
* **@Embeddable**: The `@Embeddable` annotation is a Java feature that identifies a class that can be embedded within another entity. It enables developers to create intricate data structures by combining reusable components. This technique makes it possible to represent finer-grained attributes of an entity by using an embeddable class, which encapsulates related data fields into a single logical unit. There are two types of embedding strategies that can be used with this annotation: flattening and grouping. In the flattening strategy, the fields of the embeddable class are directly added to the data schema of the parent entity. In contrast, in the grouping strategy, the fields are grouped within a structured type.
* **@Id**: Central to the entity model is the `@Id` annotation, which designates a field as the primary key. This annotation empowers developers to define the unique identifier for each entity, ensuring data integrity and facilitating efficient data retrieval operations.
* **@Column**: The `@Column` annotation provides fine-grained control over mapping entity properties to database fields. By annotating fields with `@Column`, developers customize the storage and retrieval of data, specifying attributes such as column names, types, and constraints.
* **@Convert**: With the `@Convert` annotation, developers can seamlessly transform entity attribute values between Java and database types. This annotation offers flexibility in data representation, allowing developers to adapt entity properties to suit the requirements of different database systems.
* **@MappedSuperclass**: The `@MappedSuperclass` annotation is used to define shared attributes and behaviors across multiple entity classes by denoting a superclass whose mappings are applied to its subclasses.
* **@Inheritance**: The @Inheritance annotation facilitates modeling inheritance hierarchies within entity classes. By default, Jakarta NoSQL supports a single inheritance strategy where subclass information is incorporated into the data structure as a field within the parent entity. In this default strategy, attributes of subclasses are represented as fields within the parent entity, maintaining a denormalized data structure. However, Jakarta NoSQL allows Jakarta Data providers to offer alternative inheritance strategies beyond the default specification.
* **@DiscriminatorValue**: When using inheritance strategies, the `@DiscriminatorValue` annotation specifies the discriminator value for entities in a single table inheritance hierarchy. This annotation enables database systems to differentiate between subclasses based on a discriminator column value.
* **@DiscriminatorColumn**: The `@DiscriminatorColumn` annotation configures the discriminator column used in single table inheritance mappings. By annotating a field with `@DiscriminatorColumn`, developers control the storage of discriminator values, ensuring accurate and efficient retrieval of entity subclasses.

In essence, Jakarta NoSQL annotations empower developers to craft sophisticated data models that seamlessly bridge the gap between Java entities and NoSQL databases. With a rich array of annotations at their disposal, developers can unlock the full potential of NoSQL technology, building scalable, efficient, and maintainable applications within the Jakarta EE ecosystem.

=== @Entity

The `@Entity` annotation is the cornerstone for defining persistent entities within Jakarta NoSQL. By annotating a Java class with `@Entity`, developers signify its role as a persistent entity, eligible for storage and retrieval in a NoSQL database. This annotation encapsulates the lifecycle management of entities, facilitating seamless integration with various NoSQL data stores.

==== Entity Definition Reference

First, let's establish a reference for entity definition, denoted by <<entity_definition>>. In Jakarta NoSQL, an entity class is typically annotated with `@Entity` to indicate its persistent nature.

[source,java]
----
@Entity
public class Person {

@Id
private UUID id;
@Column
private String name;
}
----

In this example, the `Person` class is defined as an entity with an `id` field annotated with `@Id`, which designates it as the primary key, and a `name` field annotated with `@Column`, indicating it as a persistent attribute.

One of the notable features of Jakarta NoSQL is its support for immutable and mutable entity classes. For immutable classes, Jakarta NoSQL provides compatibility with Java records, allowing developers to define compact and immutable entity structures concisely.

[source,java]
----
@Entity
public record Person(@Id private UUID id, @Column private String name) {
}
----

In this sample, the `Person` class is defined as a record, capturing its immutable nature. The `@Id` and `@Column` annotations are applied directly to the constructor parameters, indicating the primary key and persistent attributes.

The serialization method of entity classes may vary depending on the NoSQL vendor and configuration. Here's a sample JSON structure representing a `Person` entity:

[source,json]
----
{
  "id": "550e8400-e29b-41d4-a716-446655440000",
  "name": "John Doe"
}
----

This JSON structure captures the serialized representation of a `Person` entity with its `id` and `name` attributes. The specific serialization method may differ based on the chosen NoSQL vendor and its corresponding serialization mechanisms.

==== Associating with Other Entities

One of the powerful features of Jakarta NoSQL is its ability to associate entities with each other, enabling the creation of complex data structures. When an entity is related to another entity, it is incorporated as an embeddable group within the parent entity, as defined by <<embeddable_definition>>. Let's consider an example where a `Person` entity is associated with an `Address` entity:

[source,java]
----
@Entity
public class Person {

    @Id
    private Long id;

    @Column
    private String name;

    @Column
    private Address address;
}

@Entity
public class Address {

    @Column
    private String street;

    @Column
    private String city;
}
----

In this example, the `Person` entity includes a field `address` of type `Address`, indicating the association between the two entities. The `address` field will be represented as a nested structure within the `Person` entity when serialized.

The serialization method of entity classes may vary depending on the NoSQL vendor. Here's a sample JSON structure representing a `Person` entity with an associated `Address`:

[source,json]
----
{
   "_id":10,
   "name":"Ada Lovelace",
   "address":{
      "city":"SÃ£o Paulo",
      "street":"Av Nove de Julho"
   }
}
----

This JSON structure represents a serialized `Person` entity with `id`, `name`, and `address` attributes. The `address` field is a nested structure that includes `city` and `street` attributes from the associated `Address` entity.

Entities can also be associated using collection types like `Iterable`, such as `List` or `Set`. Let's consider an example where an `Owner` entity is associated with multiple `Car` entities:

[source,java]
----
@Entity
public class Owner {
    @Id
    private String name;
   @Column
    private List<Car> cars;
}

@Entity
public class Car {
    @Column
    private String make;
    @Column
    private String model;
}
----

In this example, the `Owner` entity includes a field `cars` of type `List<Car>`, indicating an association between the two entities. The `cars` field will hold a collection of `Car` entities associated with the `Owner`.

The serialization method of entity classes may vary depending on the NoSQL vendor. Here's a sample JSON structure representing an `Owner` entity with associated `Car` entities:

[source,json]
----
{
   "name": "marie Curie",
   "cars": [
      {
         "make": "Toyota",
         "model": "Camry"
      },
      {
         "make": "Honda",
         "model": "Accord"
      }
   ]
}
----

This JSON structure represents a serialized `Owner` entity with `name` and `cars` attributes. The `cars` field is an array containing nested structures representing associated `Car` entities.

IMPORTANT: It's important to note that not all NoSQL databases support entity associations. Developers should verify the compatibility of association features with their chosen database technology.

=== @Embeddable

The `@Embeddable` annotation in Jakarta NoSQL marks a class as embeddable, as defined by <<embeddable_definition>>. An embeddable class is a class whose instances are stored as an intrinsic part of an owning entity and share the identity of the entity. Each of the persistent properties or fields of the embedded object is mapped to the database table for the entity.

By default, the embedding strategy is FLAT, where the fields of the embedded class are directly mapped to columns in the owning entity's table.

In the example below:

[source,java]
----
@Embeddable
public class Address {
    @Column
    private String street;
    @Column
    private String city;
    @Column
    private String postalCode;
}

@Entity
public class Person {
    @Id
    private Long id;
    @Column
    private String name;
    @Column
    private Address address;  // embedded field
}
----

Here's the JSON sample for *FLAT* embedding:

[source,json]
----
{
   "id": 1,
   "name": "John Doe",
   "address_street": "123 Main St",
   "address_city": "Sampleville",
   "address_postalCode": "12345"
}
----

In addition to *FLAT*, the *GROUPING* embedding strategy is also available. In GROUPING embedding, the fields of the embedded class are grouped together within a structured type in the owning entity's table.

To specify GROUPING embedding, use `@Embeddable(GROUPING)`.

Here's the JSON sample for GROUPING embedding:

[source,json]
----
{
   "id": 1,
   "name": "John Doe",
   "address": {
      "street": "123 Main St",
      "city": "Sampleville",
      "postalCode": "12345"
   }
}
----

=== @Id

The `@Id` annotation in Jakarta NoSQL defines the unique identifier for entities within a database. For any entity, it is mandatory to have a field annotated with `@Id` to identify each instance uniquely. According to the specification, the field annotated with `@Id` must be of a basic type defined by <<basic_types>>.

While the `@Id` annotation allows for a native name, it's essential to note that some NoSQL databases have reserved keywords for their keys. In such cases, if the native name conflicts with a database keyword, the database might ignore it.

Jakarta NoSQL does not provide any strategy for autoincrement when the field annotated with `@Id` is not filled up. The behavior varies with the NoSQL database. For instance, in a Key-Value NoSQL database, a null value for an ID will generate a `NullPointerException`. In other NoSQL databases, it might vary from generating a value to returning an exception error.

Let's consider an example:

[source,java]
----
@Entity
public class User {

    @Id
    private String userName;

    @Column
    private String name;

    @Column
    private List<String> phones;
}
----

In this example, the `User` entity includes a field `userName` annotated with `@Id`, indicating that `userName` serves as the unique identifier for instances of the `User` entity.

Here's a generated JSON sample of this structure:

[source,json]
----
{
   "userName": "john_doe",
   "name": "John Doe",
   "phones": [
      "123456789",
      "987654321"
   ]
}
----

This JSON structure represents a serialized `User` entity with `userName`, `name`, and `phones` attributes. The `userName` field acts as the unique identifier for the entity.

=== @Column

The `@Column` annotation in Jakarta NoSQL marks fields that should be mapped to database columns within an entity, similar to the `@Id` annotation.

In the example below:

[source,java]
----
@Entity
public class Person {
    @Column
    private String nickname;

    @Column
    private String name;

    @Column
    private List<String> phones;

    // ignored for Jakarta NoSQL
    private String address;
}
----

In this example, the `Person` entity includes fields `nickname`, `name`, and `phones` annotated with `@Column`. These fields are marked for persistence, indicating that they should be mapped to database columns.

It's important to note that fields without the `@Column` annotation, such as `address` in the example, will be ignored for Jakarta NoSQL mapping.

Here's a generated JSON sample of this structure:

[source,json]
----
{
   "nickname": "john_doe",
   "name": "John Doe",
   "phones": [
      "123456789",
      "987654321"
   ]
}
----

This JSON structure represents a serialized `Person` entity with `nickname`, `name`, and `phones` attributes. The `nickname`, `name`, and `phones` fields are mapped to corresponding database columns.

NOTE: When using the `@Column` annotation, it's important to remember that Key-Value databases usually only require the `@Id` annotation to identify unique entities. The Jakarta NoSQL provider will determine how to serialize the object for storage, which can be combined with other annotations, such as Jakarta JSON Binding, to customize the serialization process. This flexibility allows developers to adapt the serialization process to the specific requirements of their database.

WARNING: If you use NoSQL databases that serialize information to JSON, A Jakarta NoSQL provider can integrate them with Jakarta JSON Binding annotations. The Jakarta NoSQL provider will define the integration process, ensuring a smooth and efficient serialization of data to the JSON format.

=== @Convert

The `@Convert` annotation is used in Jakarta NoSQL to declare that a specific field in an entity class requires conversion using a specified converter. This annotation is useful for converting non-persistent object types to formats that are compatible with the database, which expands data storage and manipulation capabilities.

When you use the `@Convert` annotation, you must provide a converter class as an argument, which specifies the type of conversion to be performed. The converter class must implement the `AttributeConverter` interface and define methods for converting the object type from and to its database representation.

For example, consider the following entity class `Employee`:

[source,java]
----
@Entity
public class Employee {

    @Column
    private String name;

    @Column
    private Job job;

    @Column("money")
    @Convert(MoneyConverter.class)
    private MonetaryAmount salary;
}
----

In this example, the `Employee' entity's' salary' field is annotated with `@Convert`, specifying the `MoneyConverter` class as the converter. The `MoneyConverter` class implements the `AttributeConverter` interface to convert `MonetaryAmount` objects to and from their database representation.

Here's a simplified implementation of the `MoneyConverter` class:

[source,java]
----
public class MoneyConverter implements AttributeConverter<MonetaryAmount, String> {

    @Override
    public String convertToDatabaseColumn(MonetaryAmount appValue) {
        return appValue.toString();
    }

    @Override
    public MonetaryAmount convertToEntityAttribute(String dbValue) {
        return MonetaryAmount.parse(dbValue);
    }
}
----

Additionally, let's generate a JSON format for this code:

[source,json]
----
{
   "name": "John Doe",
   "job": "Software Engineer",
   "money": "USD 5000.00"
}
----

In this JSON representation, the `money` field is stored in a database-compatible format after conversion by the `MoneyConverter` class, ensuring seamless integration with the NoSQL database.